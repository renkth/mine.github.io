<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/renkth.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/renkth.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/renkth.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/renkth.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/renkth.github.io/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/renkth.github.io/images/favicon-16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/renkth.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="cookbooks,">










<meta name="description" content="字符串显示__repr__() 方法返回一个实例的代码表示形式，通常用来重新构造这个实例。 内置的 repr() 函数返回这个字符串，跟我们使用交互式解释器显示的值是一样的。 __str__() 方法将实例转换为一个字符串，使用 str() 或 print() 函数会输出这个字符串">
<meta name="keywords" content="cookbooks">
<meta property="og:type" content="article">
<meta property="og:title" content="第八章：类与对象(1)">
<meta property="og:url" content="https://renkth.github.io/renkth.github.io/2019/03/20/第八章：类与对象/index.html">
<meta property="og:site_name" content="我的一分59s">
<meta property="og:description" content="字符串显示__repr__() 方法返回一个实例的代码表示形式，通常用来重新构造这个实例。 内置的 repr() 函数返回这个字符串，跟我们使用交互式解释器显示的值是一样的。 __str__() 方法将实例转换为一个字符串，使用 str() 或 print() 函数会输出这个字符串">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-03-20T12:38:06.765Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第八章：类与对象(1)">
<meta name="twitter:description" content="字符串显示__repr__() 方法返回一个实例的代码表示形式，通常用来重新构造这个实例。 内置的 repr() 函数返回这个字符串，跟我们使用交互式解释器显示的值是一样的。 __str__() 方法将实例转换为一个字符串，使用 str() 或 print() 函数会输出这个字符串">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/renkth.github.io/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://renkth.github.io/renkth.github.io/2019/03/20/第八章：类与对象/">





  <title>第八章：类与对象(1) | 我的一分59s</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-135017890-1', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d9a204c2011fa08e81c9fce4cb0a6697";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
	<a href="https://github.com/renkth" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/renkth.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">我的一分59s</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">格物致知</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-首页">
          <a href="/renkth.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-标签">
          <a href="/renkth.github.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-分类">
          <a href="/renkth.github.io/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-时间轴">
          <a href="/renkth.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            时间轴
          </a>
        </li>
      
        
        <li class="menu-item menu-item-关于">
          <a href="/renkth.github.io/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://renkth.github.io/renkth.github.io/renkth.github.io/2019/03/20/第八章：类与对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我的一分59s">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/renkth.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一分59s">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">第八章：类与对象(1)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-20T00:00:00+08:00">
                2019-03-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/renkth.github.io/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="字符串显示"><a href="#字符串显示" class="headerlink" title="字符串显示"></a>字符串显示</h3><p><code>__repr__()</code> 方法返回一个实例的代码表示形式，通常用来重新构造这个实例。 内置的 <code>repr()</code> 函数返回这个字符串，跟我们使用交互式解释器显示的值是一样的。 <code>__str__()</code> 方法将实例转换为一个字符串，使用 <code>str()</code> 或 <code>print()</code> 函数会输出这个字符串 </p>
<a id="more"></a>
<h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p>为了自定义字符串的格式化，我们需要在类上面定义 <code>__format__()</code> 方法 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">_format = &#123;</span><br><span class="line">    &apos;ymd&apos;:&apos;&#123;d.year&#125;-&#123;d.month&#125;-&#123;d.day&#125;&apos;,</span><br><span class="line">    &apos;mdy&apos;:&apos;&#123;d.month&#125;-&#123;d.day&#125;-&#123;d.year&#125;&apos;,</span><br><span class="line">    &apos;dym&apos; : &apos;&#123;d.day&#125;-&#123;d.month&#125;-&#123;d.year&#125;&apos;</span><br><span class="line">&#125;</span><br><span class="line">class Date:</span><br><span class="line">    def __init__(self,year,month,day):</span><br><span class="line">        self.year = year</span><br><span class="line">        self.month = month</span><br><span class="line">        self.day = day</span><br><span class="line">    def __format__(self, code):</span><br><span class="line">        if code == &quot;&quot;:</span><br><span class="line">            code = &quot;ymd&quot;</span><br><span class="line">        fmt = _format[code]</span><br><span class="line">        return fmt.format(d=self)</span><br><span class="line"></span><br><span class="line">d = Date(2019,3,20)</span><br><span class="line">print (format(d))</span><br><span class="line">print (format(d,&apos;mdy&apos;))</span><br></pre></td></tr></table></figure>
<h3 id="让对象支持上下文管理协议with语句"><a href="#让对象支持上下文管理协议with语句" class="headerlink" title="让对象支持上下文管理协议with语句"></a>让对象支持上下文管理协议with语句</h3><p>需要实现 <code>__enter__()</code> 和 <code>__exit__()</code> 方法 </p>
<p>当出现 <code>with</code> 语句的时候，对象的 <code>__enter__()</code> 方法被触发， 它返回的值(如果有的话)会被赋值给 <code>as</code> 声明的变量。然后，<code>with</code> 语句块里面的代码开始执行。 最后，<code>__exit__()</code> 方法被触发进行清理工作。 </p>
<h3 id="创建大量对象是节省内存的方法"><a href="#创建大量对象是节省内存的方法" class="headerlink" title="创建大量对象是节省内存的方法"></a>创建大量对象是节省内存的方法</h3><p>通过给类添加<code>__slot__</code> 属性来极大的减少示例所占用的内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Date:</span><br><span class="line">    __slots__ = [&quot;year&quot;,&quot;month&quot;,&quot;day&quot;]</span><br><span class="line">    def __init__(self,year,month,day):</span><br><span class="line">        self.year = year</span><br><span class="line">        self.month = month</span><br><span class="line">        self.day = day</span><br></pre></td></tr></table></figure>
<p>当你定义<code>__slot__</code>后，python就会为示例使用一种更加紧凑的内部标识，实例通过一个很小的固定大小的数组来构建，而不是为每一个示例定义一个字典，这就和元组或者列表很类似，在<code>__slot__</code> 中列出的属性名在内部被映射到这个数组的指定小表上，使用<code>__slot__</code>    的不好之处就是我们不能再给示例添加新的属性，只能使用在定义过的那些属性名。</p>
<p><strong>使用slot后节省的内存会跟存储属性的数量和类型有关，不过一般来讲，使用到的内存总量和将数据存储在一个元组中差不多</strong></p>
<p><strong>尽管slots看上去是一个很有用的特性，很多时候你还是得减少对它的使用冲动。 Python的很多特性都依赖于普通的基于字典的实现。 另外，定义了slots后的类不再支持一些普通类特性了，比如多继承。 大多数情况下，你应该只在那些经常被使用到的用作数据结构的类上定义slots (比如在程序中需要创建某个类的几百万个实例对象)</strong></p>
<blockquote>
<p>关于 <code>__slots__</code> 的一个常见误区是它可以作为一个封装工具来防止用户给实例增加新的属性。 尽管使用slots可以达到这样的目的，但是这个并不是它的初衷。 <code>__slots__</code> 更多的是用来作为一个内存优化工具 </p>
</blockquote>
<h3 id="在类中封装属性名"><a href="#在类中封装属性名" class="headerlink" title="在类中封装属性名"></a>在类中封装属性名</h3><p>Python程序员不去依赖语言特性去封装数据，而是通过遵循一定的属性和方法命名规约来达到这个效果。 第一个约定是任何以单下划线_开头的名字都应该是内部实现 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Date:</span><br><span class="line">    __slots__ = [&quot;year&quot;,&quot;month&quot;,&quot;day&quot;]</span><br><span class="line">    def __init__(self,year,month,day):</span><br><span class="line">        self.year = year</span><br><span class="line">        self.month = month</span><br><span class="line">        self.day = day</span><br><span class="line">    def _as(self):</span><br><span class="line">        print(&quot;单下划线&quot;)</span><br><span class="line">    def __as(self):</span><br><span class="line">        print(&quot;双下划线&quot;)</span><br><span class="line"></span><br><span class="line">c = Date(2,3,4)</span><br><span class="line">print(dir(c))</span><br><span class="line">c._Date__as()</span><br></pre></td></tr></table></figure>
<p><strong>使用双下划线开始会导致访问名称变成其他形式。 比如，在前面的类B中，私有属性会被分别重命名为 <code>_B__private</code> 和 <code>_B__private_method</code> 。 这时候你可能会问这样重命名的目的是什么，答案就是继承——这种属性通过继承是无法被覆盖的。 </strong></p>
<p>上面提到有两种不同的编码约定(单下划线和双下划线)来命名私有属性，那么问题就来了：到底哪种方式好呢？ 大多数而言，你应该让你的非公共名称以单下划线开头。但是，如果你清楚你的代码会涉及到子类， 并且有些内部属性应该在子类中隐藏起来，那么才考虑使用双下划线方案。</p>
<p>还有一点要注意的是，有时候你定义的一个变量和某个保留关键字冲突，这时候可以使用单下划线作为后缀，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lambda_ = 2.0 # Trailing _ to avoid clash with lambda keyword</span><br></pre></td></tr></table></figure>
<p>这里我们并不使用单下划线前缀的原因是它避免误解它的使用初衷 (如使用单下划线前缀的目的是为了防止命名冲突而不是指明这个属性是私有的)。 通过使用单下划线后缀可以解决这个问题。</p>
<h3 id="创建可管理的属性"><a href="#创建可管理的属性" class="headerlink" title="创建可管理的属性"></a>创建可管理的属性</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>你想给某个实例attribute增加除访问与修改之外的其他处理逻辑，比如类型检查或合法性验证。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>自定义某个属性的一种简单方法是将它定义为一个property。 例如，下面的代码定义了一个property，增加对一个属性简单的类型检查：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def __init__(self, first_name):</span><br><span class="line">        self.first_name = first_name</span><br><span class="line"></span><br><span class="line">    # Getter function</span><br><span class="line">    @property</span><br><span class="line">    def first_name(self):</span><br><span class="line">        return self._first_name</span><br><span class="line"></span><br><span class="line">    # Setter function</span><br><span class="line">    @first_name.setter</span><br><span class="line">    def first_name(self, value):</span><br><span class="line">        if not isinstance(value, str):</span><br><span class="line">            raise TypeError(&apos;Expected a string&apos;)</span><br><span class="line">        self._first_name = value</span><br><span class="line"></span><br><span class="line">    # Deleter function (optional)</span><br><span class="line">    @first_name.deleter</span><br><span class="line">    def first_name(self):</span><br><span class="line">        raise AttributeError(&quot;Can&apos;t delete attribute&quot;)</span><br></pre></td></tr></table></figure>
<p>上述代码中有三个相关联的方法，这三个方法的名字都必须一样。 第一个方法是一个 <code>getter</code> 函数，它使得 <code>first_name</code> 成为一个属性。 其他两个方法给 <code>first_name</code> 属性添加了 <code>setter</code> 和 <code>deleter</code> 函数。 需要强调的是只有在 <code>first_name</code> 属性被创建后， 后面的两个装饰器 <code>@first_name.setter</code> 和 <code>@first_name.deleter</code> 才能被定义。</p>
<p>property的一个关键特征是它看上去跟普通的attribute没什么两样， 但是访问它的时候会自动触发 <code>getter</code> 、<code>setter</code> 和 <code>deleter</code> 方法。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = Person(&apos;Guido&apos;)</span><br><span class="line">&gt;&gt;&gt; a.first_name # Calls the getter</span><br><span class="line">&apos;Guido&apos;</span><br><span class="line">&gt;&gt;&gt; a.first_name = 42 # Calls the setter</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    File &quot;prop.py&quot;, line 14, in first_name</span><br><span class="line">        raise TypeError(&apos;Expected a string&apos;)</span><br><span class="line">TypeError: Expected a string</span><br><span class="line">&gt;&gt;&gt; del a.first_name</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: can`t delete attribute</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>在实现一个property的时候，底层数据(如果有的话)仍然需要存储在某个地方。 因此，在get和set方法中，你会看到对 <code>_first_name</code> 属性的操作，这也是实际数据保存的地方。 另外，你可能还会问为什么 <code>__init__()</code> 方法中设置了 <code>self.first_name</code> 而不是 <code>self._first_name</code> 。 在这个例子中，我们创建一个property的目的就是在设置attribute的时候进行检查。 因此，你可能想在初始化的时候也进行这种类型检查。通过设置 <code>self.first_name</code> ，自动调用 <code>setter</code> 方法， 这个方法里面会进行参数的检查，否则就是直接访问 <code>self._first_name</code>了。</p>
<p>还能在已存在的get和set方法基础上定义property。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def __init__(self, first_name):</span><br><span class="line">        self.set_first_name(first_name)</span><br><span class="line"></span><br><span class="line">    # Getter function</span><br><span class="line">    def get_first_name(self):</span><br><span class="line">        return self._first_name</span><br><span class="line"></span><br><span class="line">    # Setter function</span><br><span class="line">    def set_first_name(self, value):</span><br><span class="line">        if not isinstance(value, str):</span><br><span class="line">            raise TypeError(&apos;Expected a string&apos;)</span><br><span class="line">        self._first_name = value</span><br><span class="line"></span><br><span class="line">    # Deleter function (optional)</span><br><span class="line">    def del_first_name(self):</span><br><span class="line">        raise AttributeError(&quot;Can&apos;t delete attribute&quot;)</span><br><span class="line"></span><br><span class="line">    # Make a property from existing get/set methods</span><br><span class="line">    name = property(get_first_name, set_first_name, del_first_name)</span><br></pre></td></tr></table></figure>
<h4 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h4><p>一个property属性其实就是一系列相关绑定方法的集合。如果你去查看拥有property的类， 就会发现property本身的fget、fset和fdel属性就是类里面的普通方法。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Person.first_name.fget</span><br><span class="line">&lt;function Person.first_name at 0x1006a60e0&gt;</span><br><span class="line">&gt;&gt;&gt; Person.first_name.fset</span><br><span class="line">&lt;function Person.first_name at 0x1006a6170&gt;</span><br><span class="line">&gt;&gt;&gt; Person.first_name.fdel</span><br><span class="line">&lt;function Person.first_name at 0x1006a62e0&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>通常来讲，你不会直接取调用fget或者fset，它们会在访问property的时候自动被触发。</p>
<p>只有当你确实需要对attribute执行其他额外的操作的时候才应该使用到property。 有时候一些从其他编程语言(比如Java)过来的程序员总认为所有访问都应该通过getter和setter， 所以他们认为代码应该像下面这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def __init__(self, first_name):</span><br><span class="line">        self.first_name = first_name</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def first_name(self):</span><br><span class="line">        return self._first_name</span><br><span class="line"></span><br><span class="line">    @first_name.setter</span><br><span class="line">    def first_name(self, value):</span><br><span class="line">        self._first_name = value</span><br></pre></td></tr></table></figure>
<p>不要写这种没有做任何其他额外操作的property。 首先，它会让你的代码变得很臃肿，并且还会迷惑阅读者。 其次，它还会让你的程序运行起来变慢很多。 最后，这样的设计并没有带来任何的好处。 特别是当你以后想给普通attribute访问添加额外的处理逻辑的时候， 你可以将它变成一个property而无需改变原来的代码。 因为访问attribute的代码还是保持原样。</p>
<p>Properties还是一种定义动态计算attribute的方法。 这种类型的attributes并不会被实际的存储，而是在需要的时候计算出来。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line">class Circle:</span><br><span class="line">    def __init__(self, radius):</span><br><span class="line">        self.radius = radius</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def area(self):</span><br><span class="line">        return math.pi * self.radius ** 2</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def diameter(self):</span><br><span class="line">        return self.radius * 2</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def perimeter(self):</span><br><span class="line">        return 2 * math.pi * self.radius</span><br></pre></td></tr></table></figure>
<p>在这里，我们通过使用properties，将所有的访问接口形式统一起来， 对半径、直径、周长和面积的访问都是通过属性访问，就跟访问简单的attribute是一样的。 如果不这样做的话，那么就要在代码中混合使用简单属性访问和方法调用。 下面是使用的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c = Circle(4.0)</span><br><span class="line">&gt;&gt;&gt; c.radius</span><br><span class="line">4.0</span><br><span class="line">&gt;&gt;&gt; c.area  # Notice lack of ()</span><br><span class="line">50.26548245743669</span><br><span class="line">&gt;&gt;&gt; c.perimeter  # Notice lack of ()</span><br><span class="line">25.132741228718345</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>尽管properties可以实现优雅的编程接口，但有些时候你还是会想直接使用getter和setter函数。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p = Person(&apos;Guido&apos;)</span><br><span class="line">&gt;&gt;&gt; p.get_first_name()</span><br><span class="line">&apos;Guido&apos;</span><br><span class="line">&gt;&gt;&gt; p.set_first_name(&apos;Larry&apos;)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>这种情况的出现通常是因为Python代码被集成到一个大型基础平台架构或程序中。 例如，有可能是一个Python类准备加入到一个基于远程过程调用的大型分布式系统中。 这种情况下，直接使用get/set方法(普通方法调用)而不是property或许会更容易兼容。</p>
<p>最后一点，不要像下面这样写有大量重复代码的property定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def __init__(self, first_name, last_name):</span><br><span class="line">        self.first_name = first_name</span><br><span class="line">        self.last_name = last_name</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def first_name(self):</span><br><span class="line">        return self._first_name</span><br><span class="line"></span><br><span class="line">    @first_name.setter</span><br><span class="line">    def first_name(self, value):</span><br><span class="line">        if not isinstance(value, str):</span><br><span class="line">            raise TypeError(&apos;Expected a string&apos;)</span><br><span class="line">        self._first_name = value</span><br><span class="line"></span><br><span class="line">    # Repeated property code, but for a different name (bad!)</span><br><span class="line">    @property</span><br><span class="line">    def last_name(self):</span><br><span class="line">        return self._last_name</span><br><span class="line"></span><br><span class="line">    @last_name.setter</span><br><span class="line">    def last_name(self, value):</span><br><span class="line">        if not isinstance(value, str):</span><br><span class="line">            raise TypeError(&apos;Expected a string&apos;)</span><br><span class="line">        self._last_name = value</span><br></pre></td></tr></table></figure>
<p>重复代码会导致臃肿、易出错和丑陋的程序。好消息是，通过使用装饰器或闭包，有很多种更好的方法来完成同样的事情。</p>
<h3 id="调用父类方法"><a href="#调用父类方法" class="headerlink" title="调用父类方法"></a>调用父类方法</h3><p>为了调用父类(超类)的一个方法，可以使用 <code>super()</code> 函数，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A:</span><br><span class="line">    def spam(self):</span><br><span class="line">        print(&apos;A.spam&apos;)</span><br><span class="line"></span><br><span class="line">class B(A):</span><br><span class="line">    def spam(self):</span><br><span class="line">        print(&apos;B.spam&apos;)</span><br><span class="line">        super().spam()  # Call parent spam()</span><br></pre></td></tr></table></figure>
<p><code>super()</code> 函数的一个常见用法是在 <code>__init__()</code> 方法中确保父类被正确的初始化了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.x = 0</span><br><span class="line"></span><br><span class="line">class B(A):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.y = 1</span><br></pre></td></tr></table></figure>
<p><code>super()</code> 的另外一个常见用法出现在覆盖Python特殊方法的代码中，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Proxy:</span><br><span class="line">    def __init__(self, obj):</span><br><span class="line">        self._obj = obj</span><br><span class="line"></span><br><span class="line">    # Delegate attribute lookup to internal obj</span><br><span class="line">    def __getattr__(self, name):</span><br><span class="line">        return getattr(self._obj, name)</span><br><span class="line"></span><br><span class="line">    # Delegate attribute assignment</span><br><span class="line">    def __setattr__(self, name, value):</span><br><span class="line">        if name.startswith(&apos;_&apos;):</span><br><span class="line">            super().__setattr__(name, value) # Call original __setattr__</span><br><span class="line">        else:</span><br><span class="line">            setattr(self._obj, name, value)</span><br></pre></td></tr></table></figure>
<p>在上面代码中，<code>__setattr__()</code> 的实现包含一个名字检查。 如果某个属性名以下划线(_)开头，就通过 <code>super()</code> 调用原始的 <code>__setattr__()</code> ， 否则的话就委派给内部的代理对象 <code>self.\_obj</code> 去处理。 这看上去有点意思，因为就算没有显式的指明某个类的父类， <code>super()</code> 仍然可以有效的工作。 </p>
<p>对于你定义的每一个类，Python会计算出一个所谓的方法解析顺序(MRO)列表。 这个MRO列表就是一个简单的所有基类的线性顺序表。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; C.__mro__</span><br><span class="line">(&lt;class &apos;__main__.C&apos;&gt;, &lt;class &apos;__main__.A&apos;&gt;, &lt;class &apos;__main__.B&apos;&gt;,</span><br><span class="line">&lt;class &apos;__main__.Base&apos;&gt;, &lt;class &apos;object&apos;&gt;)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>为了实现继承，Python会在MRO列表上从左到右开始查找基类，直到找到第一个匹配这个属性的类为止。</p>
<p>而这个MRO列表的构造是通过一个C3线性化算法来实现的。 我们不去深究这个算法的数学原理，它实际上就是合并所有父类的MRO列表并遵循如下三条准则：</p>
<ul>
<li>子类会先于父类被检查</li>
<li>多个父类会根据它们在列表中的顺序被检查</li>
<li>如果对下一个类存在两个合法的选择，选择第一个父类</li>
</ul>
<p>老实说，你所要知道的就是MRO列表中的类顺序会让你定义的任意类层级关系变得有意义。</p>
<p>当你使用 <code>super()</code> 函数时，Python会在MRO列表上继续搜索下一个类。 只要每个重定义的方法统一使用 <code>super()</code> 并只调用它一次， 那么控制流最终会遍历完整个MRO列表，每个方法也只会被调用一次。 这也是为什么在第二个例子中你不会调用两次 <code>Base.__init__()</code> 的原因。</p>
<p><code>super()</code> 有个令人吃惊的地方是它并不一定去查找某个类在MRO中下一个直接父类， 你甚至可以在一个没有直接父类的类中使用它。例如，考虑如下这个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A:</span><br><span class="line">    def spam(self):</span><br><span class="line">        print(&apos;A.spam&apos;)</span><br><span class="line">        super().spam()</span><br></pre></td></tr></table></figure>
<p>如果你试着直接使用这个类就会出错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = A()</span><br><span class="line">&gt;&gt;&gt; a.spam()</span><br><span class="line">A.spam</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    File &quot;&lt;stdin&gt;&quot;, line 4, in spam</span><br><span class="line">AttributeError: &apos;super&apos; object has no attribute &apos;spam&apos;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>但是，如果你使用多继承的话看看会发生什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class B:</span><br><span class="line">...     def spam(self):</span><br><span class="line">...         print(&apos;B.spam&apos;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class C(A,B):</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; c = C()</span><br><span class="line">&gt;&gt;&gt; c.spam()</span><br><span class="line">A.spam</span><br><span class="line">B.spam</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>你可以看到在类A中使用 <code>super().spam()</code> 实际上调用的是跟类A毫无关系的类B中的 <code>spam()</code> 方法。 这个用类C的MRO列表就可以完全解释清楚了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; C.__mro__</span><br><span class="line">(&lt;class &apos;__main__.C&apos;&gt;, &lt;class &apos;__main__.A&apos;&gt;, &lt;class &apos;__main__.B&apos;&gt;,</span><br><span class="line">&lt;class &apos;object&apos;&gt;)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>在定义混入类的时候这样使用 <code>super()</code> 是很普遍的。可以参考8.13和8.18小节。</p>
<p>然而，由于 <code>super()</code> 可能会调用不是你想要的方法，你应该遵循一些通用原则。 首先，确保在继承体系中所有相同名字的方法拥有可兼容的参数签名(比如相同的参数个数和参数名称)。 这样可以确保 <code>super()</code> 调用一个非直接父类方法时不会出错。 其次，最好确保最顶层的类提供了这个方法的实现，这样的话在MRO上面的查找链肯定可以找到某个确定的方法。</p>
<p>在Python社区中对于 <code>super()</code> 的使用有时候会引来一些争议。 尽管如此，如果一切顺利的话，你应该在你最新代码中使用它。 Raymond Hettinger为此写了一篇非常好的文章 <a href="http://rhettinger.wordpress.com/2011/05/26/super-considered-super" target="_blank" rel="noopener">“Python’s super() Considered Super!”</a> ， 通过大量的例子向我们解释了为什么 <code>super()</code> 是极好的。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/renkth.github.io/tags/cookbooks/" rel="tag"># cookbooks</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/renkth.github.io/2019/03/02/迭代对象-迭代器-生成器/" rel="next" title="迭代对象 迭代器 生成器">
                <i class="fa fa-chevron-left"></i> 迭代对象 迭代器 生成器
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/renkth.github.io/2019/03/20/python的执行顺序/" rel="prev" title="python的执行顺序">
                python的执行顺序 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript">
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/renkth.github.io/images/user.jpg" alt="我的一分59s">
            
              <p class="site-author-name" itemprop="name">我的一分59s</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/renkth.github.io/archives">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/renkth.github.io/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/renkth.github.io/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/renkth" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串显示"><span class="nav-number">1.</span> <span class="nav-text">字符串显示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串格式化"><span class="nav-number">2.</span> <span class="nav-text">字符串格式化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#让对象支持上下文管理协议with语句"><span class="nav-number">3.</span> <span class="nav-text">让对象支持上下文管理协议with语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建大量对象是节省内存的方法"><span class="nav-number">4.</span> <span class="nav-text">创建大量对象是节省内存的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在类中封装属性名"><span class="nav-number">5.</span> <span class="nav-text">在类中封装属性名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建可管理的属性"><span class="nav-number">6.</span> <span class="nav-text">创建可管理的属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#问题"><span class="nav-number">6.1.</span> <span class="nav-text">问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解决方案"><span class="nav-number">6.2.</span> <span class="nav-text">解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#讨论"><span class="nav-number">6.3.</span> <span class="nav-text">讨论</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调用父类方法"><span class="nav-number">7.</span> <span class="nav-text">调用父类方法</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">我的一分59s</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/renkth.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/renkth.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/renkth.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/renkth.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/renkth.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/renkth.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/renkth.github.io/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/renkth.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/renkth.github.io/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/renkth.github.io/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/renkth.github.io/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/renkth.github.io/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/renkth.github.io/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/renkth.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
